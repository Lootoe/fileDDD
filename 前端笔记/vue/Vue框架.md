## Vue框架

### MVC

**介绍**

`view`：页面的显示与交互逻辑，用户交互就通知`Controller`

`model`：存储业务数据，以及对数据的相关操作，通知`view`层视图更新

`controller`：响应用户操作，对`model`层进行修改

**优点**

降低耦合性：三个层各施其职，所以如果一旦哪一层的需求发 生了变化，就只需要更改相应的层中的代码而不会影响到其他层中的代码

有利于分工：网页设计人员可进行开发视图层，而对业务熟悉的人员可开发业务层，而其他开发人员可开发控制层

有利于代码复用：一个数据模型可以被多个视图层复用

**缺点**

增加系统复杂性：对于简单的界面，严格遵循 MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率

`view`与`controller`耦合：联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。



### MVVM

**介绍**

Model（Vue中的data，methods等）：代表数据模型，数据和业务逻辑都在Model层中定义

View（template）：代表UI视图，负责数据的展示；

ViewModel（Vue实例）：它持有model，与view双向绑定，当Model中数据的改变，自动控制view的更新，处理用户交互操作

**优点**

低耦合：分离视图（View）和模型（Model），view 和 moel都可以独立修改

提高可测试性： ViewModel的存在可以帮助开发者更好地编写测试代码 

自动更新DOM：利双向绑定，数据更新后视图动更新，让开发者从繁琐的动dom中解放

**缺点**

BUG难调试：界面异常了，不好排查是view还是model的问题，另外vue的指令也没办法打断点调试

浪费内存：一个大的模块中model也会很大，当时长期持有，不释放内存就造成了花费更多的内存

无法重用model：因为数据双向绑定，view与Model绑定在一起，无法重用model



### SPA优缺点

**介绍**

SPA一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转

取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

**优点**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。



### Vue性能优化

**（1）编码阶段**

- 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
- v-if和v-for不能连用
- 如果需要使用v-for给每项元素绑定事件时使用事件代理
- SPA 页面采用keep-alive缓存组件
- 在更多的情况下，使用v-if替代v-show
- key保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

**（2）SEO优化**

- 预渲染
- 服务端渲染SSR

**（3）打包优化**

- 压缩代码
- Tree Shaking/Scope Hoisting
- 使用cdn加载第三方模块
- 多线程打包happypack
- splitChunks抽离公共文件
- sourceMap优化

**（4）用户体验**

- 骨架屏
- PWA
- 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等



### Vue页面初始化闪动

使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象

看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的

首先：在css里加上以下代码：

```javascript
// template
// v-cloak这个属性在vue的实例加载完之后关联结束
<div id="app" v-cloak>  {{a}}  </div> 
// css
[v-cloak] {display: none;}
// 如果没有彻底解决问题，则在根元素加上style="display: none;" :style="{display: 'block'}"。
```



