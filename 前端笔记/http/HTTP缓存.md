# HTTP缓存

### 缓存类型

**内存缓存（memory cache）**：读取速度快，但是只在进程期间有效，关闭标签页就失效：缓存`媒体文件`

**磁盘缓存（disk cache）**：读取速度慢，但永久有效：`缓存css/js`



### 缓存能解决什么问题

- 减少不必要的网络传输，节约宽带
- 更快的加载页面
- 减少服务器负载，避免服务器过载的情况出现

而缓存有两种策略：强制缓存、协商缓存

强制缓存：浏览器自己判断是否采用缓存

协商缓存：与服务器交互判断是否采用缓存



### 强制缓存：Expires

`Expires`字段的作用是，设定一个强缓存时间，在此时间范围内，则从内存（或磁盘）中读取缓存返回

比如说将某一资源设置响应头为：`Expires:new Date("2022-7-30 23:59:59")`

那么，该资源在`2022-7-30 23:59:59` 之前，都会去本地的磁盘（或内存）中读取，不会去服务器请求

但是Expires已经被废弃了，因为`Expires`过度依赖本地时间

如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况



### 强制缓存：Cache-control

`Cache-control`完美解决了`Expires`本地时间和服务器时间不同步的问题

`Cache-control`的使用方法很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒

```js
// 往响应头中写入需要缓存的时间
// 缓存10s
res.writeHead(200,{
    'Cache-Control':'max-age=10'
});
```

`Cache-control`有几个属性：

- `max-age-N`：决定客户端资源被缓存多久
- `s-maxage-N`：决定代理服务器缓存的时长
- `no-cache`：表示是强制进行协商缓存
- `no-store`：是表示禁止任何缓存策略
- `public`：表示资源即可以被浏览器缓存也可以被代理服务器缓存
- `private`：表示资源只能被浏览器缓存

几个属性并用如下：

```js
Cache-control:max-age=10000,s-maxage=200000,public
```



### 协商缓存：last-modified

基于`last-modified`的协商缓存实现方式是（三步缺一不可）:

1. 首先需要在服务器端读出文件修改时间，
2. 将读出来的修改时间赋给响应头的`last-modified`字
3. 最后设置`Cache-control:no-cache`

当客户端读取到`last-modified`的时候，会在下次的请求标头中携带一个字段:`If-Modified-Since`

而这个请求头中的`If-Modified-Since`就是服务器第一次修改时候给他的时间

而服务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源

```js
const data = fs.readFileSync('./xxx.mp3')
const {mtime} = fs.statSync('./xxx.mp3')
const ifModifiedSince = req.headers['if-modified-since']
// 如果上次修改时间与当前资源的修改时间一致，就走缓存
if(ifModifiedSince ==== mtime.toUTCString()){
  res.statusCode = 304
  res.end()
  return
}
res.setHeader('last-modified',mtime.toUTCString())
res.setHeader('Cache-Control','no-cache')
res.end(data)
```



### last-modified缺点

1、在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来）

​	  这样，就有可能文件内容明明没有修改，但是缓存依然失效了

2、当文件在极短时间内完成修改的时候（比如几百毫秒）

​	  因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变



### 协商缓存：ETag

`ETag`就是将原先协商缓存的比较**时间戳**的形式修改成了比较**文件指纹**

文件指纹：根据文件内容计算出的唯一哈希值，文件内容一旦改变则指纹改变

1、第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的`etag`字段中跟资源一起返回给客户端

2、第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的`ETag`也就是文件指纹

​	  并赋给请求头的`if-None-Match`字段，让上一次的文件指纹跟随请求一起回到服务端

3、服务端拿到请求头中的`is-None-Match`字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比

​	  如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return

​	  如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的`ETag`中并返回给客户端



### ETag缺点

1、ETag需要计算文件指纹这样意味着，服务端需要更多的计算开销，

​	  如果文件尺寸大，数量多，并且计算频繁，那么ETag的计算就会影响服务器的性能

2、ETag有强验证和弱验证，所谓将强验证，ETag生成的哈希码深入到每个字节

​	  哪怕文件中只有一个字节改变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变，很消耗计算量

​	  ETag还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值

​	  因为不必精确到每个字节，所以他的整体速度会比强验证快，但是准确率不高，会降低协商缓存的有效性



### 哪些文件应该设置缓存

有哈希值的文件设置强缓存即可，没有哈希值的文件（比如index.html）设置协商缓存

比如，有一个css文件a1

第一次打包a1.css文件追加哈希值变成了 a1.aaaaa.css，我们给a1.aaaaa.css设置了强缓存1W年

然后项目改动，我们又打包了一次

打包后生产新的哈希值，a1.aaaaa.css变成了a1.bbbbb.css文件

那么当我们第一次访问a1.bbbbb.css文件的时候是不会被缓存

因为1W年的缓存是给a1.aaaaa.css文件做的关我a1.bbbbb.css文件什么事



### 用户操作对缓存的影响

| 用户操作     | 强缓存 | 协商缓存 |
| ------------ | ------ | -------- |
| 地址栏回车   | 有效   | 有效     |
| 页面跳转链接 | 有效   | 有效     |
| 新开窗口     | 有效   | 有效     |
| 前进后退     | 有效   | 有效     |
| F5刷新       | 无效   | 有效     |
| ctrl+F5      | 无效   | 无效     |

