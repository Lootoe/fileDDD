## 常用浏览器及其内核

| 浏览器  | 内核           |
| ------- | -------------- |
| Chrome  | Chromium/Blink |
| Firefox | Presto         |
| Opera   | Gecko          |
| Safari  | Webkit         |
| IE      | Trident        |



## 浏览器工作原理（需要深挖）

#### 地址栏输入URL

- 浏览器根据输入的URL进行DNS解析，查找域名的IP地址，
- 浏览器与对应Web服务器建立TCP连接
- 浏览器发送HTTP请求
- Web服务器返回HTML文件
- 浏览器解析渲染网页

#### 浏览器解析HTML

- 解析`head`标签，关于页面的一些配置标签，例如`<title>、<meta>`等，以后再进行剖析
- 遇到内联CSS与JS立即解析执行
- 碰到外部CSS和JS会并发请求相关资源，然后解析执行
- 接着，浏览器开始解析`<body>`里的内容
- 碰到需要获取其他地址内容的标签，例如`<img>、<script>`，会并发请求相关资源
- 当HTML解析器遇到`<script>`标签时，默认必须先执行脚本，然后再恢复文档的解析和渲染

#### 脚本解析

- 遇到`script`标签，暂停解析HTML，阻塞地下载脚本，然后执行，执行完成后恢复解析
- defer属性，先异步下载脚本，等待HTML解析完毕后再执行脚本
- async属性，先异步下载脚本，下载完成后暂停解析HTML，等待脚本执行后恢复解析
- 延迟脚本会按照他们在文档里的出现顺序来执行
- 异步脚本在他们载入后执行，可能会无序执行

#### 浏览器渲染流程

- 解析HTML生成DOM树
- 解析CSS生成CSS规则树
- 将DOM树和CSS规则树合并生成渲染树
- 根据渲染树来布局，以计算每个节点（标签/元素）的几何信息
- 将各个节点绘制到屏幕上

| 概念      | 说明                                                       |
| --------- | ---------------------------------------------------------- |
| DOM树     | 浏览器解析HTML成树形的数据结构                             |
| CSS规则树 | 浏览器解析CSS成树形的数据结构                              |
| 渲染树    | DOM树和CSS规则树合并后生成渲染树                           |
| 布局      | 根据渲染树所确定的每个节点的几何信息                       |
| 重排      | 当某个部分变化影响到布局时，需要重新解析该部分渲染树       |
| 重绘      | 改变某个元素的颜色时，不影响布局，此时会重绘，重新绘制颜色 |

#### 如何减少发生重排

- 使DOM脱离文档流

- 修改CSS时采用文本批量修改或者修改类

- 修改DOM时，先使用`display:none`，再使用`display:block`

- 批量操作DOM

- 避免反复操作样式

- 使用文档片段



## 垃圾回收方法

#### 引用计数法

`核心思想`：设置引用计数器，当引用关系改变时，立即修改计数，当计数为0时，立即回收

`优点`：发现垃圾立即回收、最大限度减少程序暂停

`缺点`：时间开销大，无法回收循环引用对象

#### 标记清除法

`核心思想`：暂停程序，从一组根元素遍历所有对象，遍历到的标记为活动对象，回收没有标记的对象

`优点`：可以解决循环引用问题

`缺点`：会造成空间碎片化，需要暂停程序

#### 标记整理法

`核心思想`：在标记清除法基础上加了一个整理的操作，将所有活动对象移动到一个连续的空间中

优点：解决空间碎片化，需要暂停程序



## V8引擎垃圾回收机制

#### 什么是浏览器垃圾

浏览器垃圾：当一个对象（在堆-Heap里）没有任何变量或属性（在栈中）对它进行引用，此时将永远无法操作此对象，那么这个对象就是垃圾。

#### 垃圾分类

新生代的垃圾：生存时间短的对象（如内部声明的变量，或者块级作用域中的变量等），使用完马上可以回收。

老生代的垃圾：生存时间久的对象（如挂载在windows下面的变量、JS一些API、DOM、闭包等），持久性强，需要等待用完才能回收。

#### 垃圾过多造成的影响

内存溢出：当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误。

内存泄漏：程序运行中动态申请的内存空间由于某种原因程序未释放或无法释放。

#### 堆空间分类

V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了

对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收

#### 主垃圾回收器

采用标记清除 + 标记整理

#### 副垃圾回收器

新生代被分为两个区域：一般是对象区域，一半是空闲区域。

先给对象区域所有垃圾做标记。

标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍。因为空闲区域里此时是有序的，没有碎片，也就不需要整理了。 

复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。

#### 垃圾回收时机

分代收集：将堆分为新生代与老生代，多回收新生代，少回收老生代。这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时。

增量收集：将垃圾收集工作分成更小的块，每次处理一部分，多次处理，这样就解决了长时间停顿的问题。

闲时收集：垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。

#### 闭包会导致内存泄露吗

闭包会导致内存泄露吗？正确的答案是不会。

内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。

闭包里面的变量就是我们需要的变量，不能说是内存泄露。



## DOCTYPE



## URI、URL

格式：`scheme://host.domain:port/path`

案例：`http://www.baidu.com/animals`

字符编码：URL编码会将字符通过因特网传输的格式进行发送，而URL常包含非ASCII码字符，所以用%与两位16进制数替换



## SEO

#### 合理的TDK

TDK（title、description、keywords）有利于SEO（搜索引擎优化）

```html
<title>website</title>
<meta name="keywords" content="fruits animals">
<meta name="description" content="you can buy anithing">
```

#### 合理的LOGO

1、最外层包裹h1标签

2、img包裹a标签连接到首页

3、img标签添加alt

#### 标签权重表

| 标签           | 权重 |
| -------------- | ---- |
| 内部链接文字   | 10   |
| 标题           | 10   |
| 域名           | 7    |
| h1-2           | 5    |
| 段首           | 5    |
| 路径或者文件名 | 4    |
| 加粗/斜体      | 1    |
| alt            | 1    |
| title          | 0.5  |
| description    | 0.5  |
| keywords       | 0.05 |



## 行内、块级、行内块元素

**块级元素**

- 每个块级元素都是独自占一行
- 高度，行高，外边距（margin）以及内边距（padding）都可以控制
- 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）
- 多个块状元素标签写在一起，默认排列方式为从上至下

**行内元素**

- 不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化
- 高宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效  上下无效
- 设置行高有效，等同于给父级元素设置行高
- 元素的宽度就是它包含的文字或图片的宽度，不可改变
- 行内元素中不能放块级元素，a 链接里面不能再放链接

**行内块元素**

- 高度、行高、外边距以及内边距都可以控制
- 默认宽度就是它本身内容的宽度，不独占一行，但是之间会有空白缝隙，设置它上一级的 font-size 为 0，才会消除间隙



## 渐进增强、优雅降级

**渐进增强**：一开始就**针对低版本浏览器**进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

**优雅降级**：一开始就构建**站点的完整功能**，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。



## H5离线存储

## web worker