## 缓存流程

1、用户请求资源判断是否存在缓存标识

2、不存在缓存标识，服务器返回资源并缓存，返回状态码`200`

3、存在缓存标识且没过期，直接从缓存读取资源

4、存在缓存标识但过期，请求头带上`IFS`和`INM`，发送给服务器

5、服务器资源无更新，返回状态码`304`，客户端从缓存获取资源

6、服务器资源更新，返回状态码`200`，客户端获取服务器新资源并缓存



## 缓存位置

`Memory-Cache`：内存缓存，读取速度慢，但永久有效：`缓存css`

`Disk-Cache`：硬盘缓存，读取速度快，但是只在进程期间有效，关闭标签页就失效：缓存`js与媒体文件`

`Service-worker`：是运行在浏览器背后的独立线程，无法直接访问`DOM`，但可以用来做`离线缓存`、`消息推送`和`网络代理`，传输协议必须为 `HTTPS`



## 强制缓存

### 过程

1、浏览器缓存里没有缓存标识和缓存结果，则直接向服务器发送请求获取结果

2、浏览器缓存里有缓存标识和缓存结果，但已失效，则使用协商缓存

3、浏览器缓存里有缓存标识和缓存结果，有效，则直接从缓存返回结果，将结果缓存

### Expires

`Expires`是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间

当再次发起该请求时，如果客户端的时间小于`Expires`的值时，直接使用缓存结果

但是如果客户端与服务端的时间因为某些原因（例如时区不同）发生误差，那么强制缓存则会直接失效

这样的话强制缓存的存在则毫无意义

### Cache-Control

| 字段              | 作用                                   |
| ----------------- | -------------------------------------- |
| `public`          | 使用强缓存，客户端和代理服务器都可缓存 |
| `private（默认）` | 使用强缓存，只有客户端可以缓存         |
| `no-cache`        | 客户端进行协商缓存                     |
| `no-store`        | 不使用缓存                             |
| `max-age=xxx`     | xxx秒内发起请求直接使用缓存            |

### 启发式缓存

在资源请求的响应头中没有出现`Expires` 和 `cache-control:max-age` 字段值，并且没有限制`no-store`，并且设置了`Last-Modified`，那么浏览器默认会采用一个**启发式的强缓存算法**，通常会根据响应头中的 `Date` 减去 `Last-Modified` 值的 `10%` 作为缓存时间



## 协商缓存

### 过程

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

1、协商缓存有效，返回304，从缓存获取结果

2、协商缓存失效，返回200，从服务器返回结果并缓存

### Last-Modified

`Last-Modified`：服务器响应请求时，返回该资源文件在服务器最后被修改的时间

`If-Modified-Since`：客户端再次发起该请求时，携带上次请求返回的`Last-Modified`值

**过程**：

1. 服务器根据`If-Modified-Since`的值与资源最后修改的时间对比
2. 若服务器的资源最后被修改时间大于`If-Modified-Since`的字段值，则重新返回资源，状态码为`200`
3. 代表资源无更新，可继续使用缓存文件，状态码为`304`

### ETag

`ETag`：服务器响应请求时，返回当前资源文件的一个唯一标识

`If-None-Match`：客户端再次发起该请求时，携带上次请求的`ETag`

**过程**：

1. 服务器根据`If-None-Match`的值与该资源在服务器的`eTag`值对比
2. 若一致，代表资源无更新，可继续使用缓存文件，状态码为`304`
3. 若不一致，则重新返回资源，状态码为`200`

### 什么时候使用ETag

1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，此时我们不希望客户端认为这个文件被修改了，而重新向服务器发起请求

2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，`If-Modified-Since`能检查到的粒度是秒级的，这种修改无法判断

### 为什么不建议用ETag

1、大型网站多使用负载分担的方式来调度HTTP请求，所以同一个客户端对同一个页面的多次请求，很可能被分配到不同的服务器。而不同的服务器，在其它所有方面都一样的情况下，对于同一页面也能够计算出不同的`ETag`。因此，这时，虽然页面没有发生任何变化，但是服务器还是会给出不同的`ETag`，重新发送完整的页面内容

2、 `ETag`的计算占用服务器的CPU资源，如果我们关闭了`ETag`，`Apache`服务器就会到了必须使用`Last-Modified`参数来判断的状态，这时，服务器不用消耗计算`ETag`的资源，可以提升服务器性能，提升页面加载速度，优化`SEO`



## 用户操作对缓存的影响

| 用户操作     | 强缓存 | 协商缓存 |
| ------------ | ------ | -------- |
| 地址栏回车   | 有效   | 有效     |
| 页面跳转链接 | 有效   | 有效     |
| 新开窗口     | 有效   | 有效     |
| 前进后退     | 有效   | 有效     |
| F5刷新       | 无效   | 有效     |
| ctrl+F5      | 无效   | 无效     |



## 详细参考

[一文搞懂浏览器缓存策略 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1594399)
