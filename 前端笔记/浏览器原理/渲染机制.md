## 渲染进程

`GUI渲染线程`：GUI 渲染线程负责渲染浏览器界面

`JavaScript引擎线程`（一个Tab只有一个）：主要负责解析 JavaScript 脚本并运行相关代码，**该线程与GUI渲染线程互斥**，这也是就是为什么JavaScript操作时间过长，会造成页面渲染不连贯，导致页面出现阻塞的原理

`事件线程`：控制事件循环

`定时器触发线程`：处理定时器相关逻辑

`网络线程`： 处理网络请求，比如`ajax`



## 渲染流程

1. 解析HTML生成DOM树
   - 浏览器开始解析HTML，此时`document.readystate = loading`
   - 当遇到外联CSS时，会**并行**下载解析
   - 在CSS下载解析完成之前，脚本**会下载**，但**不会执行**，因为`JS`可能会去获取或者变更`DOM`的`CSS`样式，如果此时外联`CSS`还没解析好，获取到的结果就是不准确的
   - 当遇到同步脚本时，会阻塞解析，等到脚本**下载并且执行完毕**时，才会继续解析
   - 遇到异步脚本（async），并行下载脚本，当**下载完毕**才会中断解析并执行脚本
   - 遇到异步脚本（defer），并行下载脚本，当**HTML解析完毕**才会中断解析并执行脚本
   - 如果脚本同时有async、defer属性，会只由async属性决定
   - 当文档完成解析，`document.readyState`变成 `interactive`，触发 `DOMContentLoaded事件`
   - 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，`document.readyState`变为 `complete`，`window` 触发 `load` 事件
2. 解析CSS生成CSSOM规则树
   - 浏览器从上到下、**从右到左**解析CSS，因为`从右往左`只需要最右边的一个不匹配，就可以直接舍弃，避免了许多无效匹配
   - 并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢
3. 将DOM树与CSSOM规则树合并在一起生成渲染树（CSSOM构建完毕后执行）
4. 遍历渲染树开始布局，计算每个节点的位置大小信息
5. 将渲染树每个节点绘制到屏幕
   - 构建图层树：因为页面中有很多复杂的效果，如一些 3D 变换、页面滚动、Z 轴排序等， 为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树
   - 生成绘制列表：浏览器每次都会把一个复杂的图层拆分为很小的**绘制指令**（在什么地方绘制什么东西），然后再按照这些指令的顺序组成一个**绘制列表**，并提交给合成线程
   - 光栅化：在有些情况下，有的图层很大，内容很长，为了降低绘制成本、尽可能快地呈现内容给用户，合成线程进行了一些优化， **合成线程会按照视口附近的图块优先生成位图**，合成层采用GPU，普通渲染层采用CPU
   - 合成和显示：合成线程发送绘制图块命令给渲染进程，渲染进程绘制页面（CPU处理）



## 层叠上下文

浏览器的页面实际上被分成了很多渲染层，这些渲染层叠加后合成了最终的页面。拥有层叠上下文属性的元素在生成图层树时，会被提升为单独一层

渲染层也基本上是有一些特定的CSS属性创建的，一般有以下情况：

- HTML根元素本身就具有层叠上下文
- 普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文
- 元素的 **opacity** 值不是 1
- 元素的 **transform** 值不是 none
- 元素的 **filter** 值不是 none
- 元素的 **isolation** 值是isolate
- **will-change**指定的属性值为上面任意一个，对于不支持will-change 属性的浏览器，使用一个3D transform属性来强制提升为合成 `transform: translateZ(0)`



## 回流/重排

对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生`回流`过程

读取DOM的几何尺寸也会导致回流，所以在读取之前，把DOM的修改操作放一起，以减少回流

回流与重绘都会重新走一遍整个渲染流程



## 重绘

当页面中元素样式的改变时，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为`重绘`

重绘只会重新构建CSSOM，导致重新生成一份绘制列表，然后走绘制列表后的流程

可以看到，重绘不一定导致回流，但回流一定发生了重绘



## 合成

**概述：**

某些特殊的渲染层会被认为是合成层，每个合成层会负责输出该层的位图上传给GPU合成显示

**合成层优点**：

**避免了回流跟重绘**，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以**相对于重绘和重排，合成能大大提升绘制效率**，每个合成层的修改不会影响到其他图层

如何变渲染层成合成层（GPU加速）

- 3D 或透视变换(perspective transform) CSS 属性
- 使用加速视频解码的 <video> 元素 拥有 3D
- (WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素
- 混合插件(如 Flash)
- 对自己的 opacity 做 CSS动画或使用一个动画变换的元素
- 拥有加速 CSS 过滤器的元素
- 一个元素拥有一个子元素，该子元素在自己的层里
- 该元素在复合层上面渲染
- 提升合成层的最好方式是使用 CSS 的 will-change 属性， `transform: translateZ(0)`

**层爆炸**：

一个`z-index`比较低的节点被提升为单独合成层后，层叠在它上面的元素统统都会提升为单独的合成层

我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃，这就是`层爆炸`